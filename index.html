<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modern Paint App</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="h-screen flex bg-gray-100 text-gray-800">

    <!-- Sidebar Menu: Contains buttons for Paper Options, Tools, Color Picker, and Undo -->
    <aside class="w-64 bg-white shadow-lg p-6 flex flex-col gap-6">
        <h1 class="text-2xl font-semibold text-center mb-2">Paint App</h1>
        
        <!-- Paper Section: Allows the user to select different types of paper -->
        <div>
            <h2 class="text-lg font-semibold text-gray-600 mb-2">Paper Options</h2>
            <div class="flex flex-col gap-2">
                <!-- Each button calls a JavaScript function to change the background style of the canvas -->
                <button onclick="changePaper('graph')" class="bg-blue-500 text-white py-2 rounded hover:bg-blue-600">Graph Paper</button>
                <button onclick="changePaper('lined')" class="bg-blue-500 text-white py-2 rounded hover:bg-blue-600">Lined Paper</button>
                <button onclick="changePaper('plain')" class="bg-blue-500 text-white py-2 rounded hover:bg-blue-600">Plain Paper</button>
                <button onclick="changePaper('cubed')" class="bg-blue-500 text-white py-2 rounded hover:bg-blue-600">Cubed Paper</button>
            </div>
        </div>

        <!-- Tool Section: Allows the user to choose between Draw, Erase, and Fill tools -->
        <div>
            <h2 class="text-lg font-semibold text-gray-600 mb-2">Tools</h2>
            <div class="flex flex-col gap-2">
                <!-- Buttons for each tool. When clicked, they set the mode to the corresponding tool -->
                <button onclick="setMode('draw')" class="bg-green-500 text-white py-2 rounded hover:bg-green-600">Draw</button>
                <button onclick="setMode('erase')" class="bg-yellow-500 text-white py-2 rounded hover:bg-yellow-600">Erase</button>
                <button onclick="setMode('fill')" class="bg-pink-500 text-white py-2 rounded hover:bg-pink-600">Fill</button>
            </div>
        </div>

        <!-- Color Section: Allows the user to pick a fill color for the 'Fill' tool -->
        <div>
            <h2 class="text-lg font-semibold text-gray-600 mb-2">Fill Color</h2>
            <label for="fillColor" class="block text-sm font-medium mb-1">Pick a Color:</label>
            <input type="color" id="fillColor" class="w-full h-10" value="#000000" onchange="updateFillColor()">
        </div>

        <!-- Undo Section: Provides an Undo button to remove the last drawing action -->
        <button onclick="undoLast()" class="mt-4 p-2 bg-gray-800 text-white rounded hover:bg-red-600 transition">Undo</button>
    </aside>

    <!-- Main Content: Centered Canvas where the user draws, erases, or fills -->
    <main class="flex-1 flex items-center justify-center p-6">
        <canvas id="drawingArea" class="border border-gray-300 shadow-lg" width="900" height="900"></canvas>
    </main>

    <script>
        // Get the canvas element and its 2D context for drawing
        const canvas = document.getElementById('drawingArea');
        const ctx = canvas.getContext('2d');

        // Initialize necessary variables for drawing, paths, and the current mode
        let drawing = false;
        let paths = []; // This will store all the paths drawn on the canvas
        let currentPath = []; // Stores the current path being drawn
        let mode = 'draw'; // Default mode is 'draw'
        let fillColor = [0, 0, 0, 255]; // Default color is black for filling

        // Event listener for mouse down to start drawing, erasing, or filling
        canvas.addEventListener('mousedown', (e) => {
            if (mode === 'fill') {
                const x = e.clientX - canvas.offsetLeft;
                const y = e.clientY - canvas.offsetTop;
                fillCanvas(x, y); // If mode is 'fill', start the fill process
                return;
            }
            drawing = true; // Begin drawing or erasing
            currentPath = []; // Reset current path
            draw(e); // Draw the first point
        });

        // Event listener for mouse movement to continue drawing/erasing
        canvas.addEventListener('mousemove', draw);

        // Event listener for mouse up to stop drawing/erasing
        canvas.addEventListener('mouseup', () => { 
            drawing = false; 
            if (mode === 'draw') paths.push([...currentPath]); // Save path if in drawing mode
            ctx.beginPath(); // Begin a new path
        });

        // Event listener for mouse out to stop drawing if the cursor leaves the canvas
        canvas.addEventListener('mouseout', () => { drawing = false; });

        // Function to draw on the canvas or erase based on the current mode
        function draw(e) {
            if (!drawing) return; // If not drawing, do nothing

            const x = e.clientX - canvas.offsetLeft; // Get the X position of the mouse relative to the canvas
            const y = e.clientY - canvas.offsetTop; // Get the Y position of the mouse relative to the canvas

            ctx.lineWidth = 3; // Set the line width
            ctx.lineCap = 'round'; // Set the line cap style

            // If the mode is 'draw', draw a black line
            if (mode === 'draw') {
                ctx.strokeStyle = 'black'; // Set the stroke color
                ctx.lineTo(x, y); // Draw a line to the current mouse position
                ctx.stroke(); // Apply the stroke
                ctx.beginPath(); // Start a new path at the current position
                ctx.moveTo(x, y); // Move to the current mouse position
                currentPath.push({ x, y }); // Add the point to the current path
            } 
            // If the mode is 'erase', clear a small area at the mouse position
            else if (mode === 'erase') {
                ctx.clearRect(x - 5, y - 5, 10, 10); // Erase a 10x10 area
            }
        }

        // Function to change the background of the canvas based on paper type selected
        function changePaper(type) {
            switch(type) {
                case 'graph':
                    canvas.style.background = 'linear-gradient(90deg, transparent 29px, #ddd 30px), linear-gradient(transparent 29px, #ddd 30px)';
                    canvas.style.backgroundSize = '30px 30px'; // Set background for graph paper
                    break;
                case 'lined':
                    canvas.style.background = 'linear-gradient(transparent 29px, #ddd 30px)';
                    canvas.style.backgroundSize = 'auto 30px'; // Set background for lined paper
                    break;
                case 'plain':
                    canvas.style.background = 'none'; // Remove any background for plain paper
                    break;
                case 'cubed':
                    canvas.style.background = 'linear-gradient(90deg, transparent 29px, #ddd 30px), linear-gradient(transparent 29px, #ddd 30px), linear-gradient(#ddd 1px, transparent 1px)';
                    canvas.style.backgroundSize = '30px 30px'; // Set background for cubed paper
                    break;
                default:
                    canvas.style.background = 'none'; // Default to no background
            }
        }

        // Function to set the current tool mode (draw, erase, or fill)
        function setMode(newMode) { 
            mode = newMode; // Change the tool mode
        }

        // Function to undo the last drawn path
        function undoLast() {
            if (paths.length === 0) return; // If no paths, do nothing
            paths.pop(); // Remove the last path
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
            redraw(); // Redraw all the remaining paths
        }

        // Function to redraw all the saved paths on the canvas
        function redraw() {
            paths.forEach(path => {
                ctx.beginPath(); // Start a new path
                path.forEach(point => ctx.lineTo(point.x, point.y)); // Draw the saved path
                ctx.stroke(); // Apply the stroke to the path
            });
        }

        // Function to update the fill color based on the color picker
        function updateFillColor() {
            const color = document.getElementById('fillColor').value; // Get the color from the input
            const rgb = hexToRgb(color); // Convert hex to RGB
            fillColor = [rgb.r, rgb.g, rgb.b, 255]; // Store the color with full opacity
        }

        // Function to perform a fill action on the canvas
        function fillCanvas(startX, startY) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height); // Get the current pixel data
            const pixels = imageData.data; // Extract pixel data
            const targetColor = getPixelColor(pixels, startX, startY); // Get the color at the starting point

            // If the target color is the same as the fill color, do nothing
            if (colorsMatch(targetColor, fillColor)) return;

            const pixelStack = [[startX, startY]]; // Stack to store pixels that need to be filled
            while (pixelStack.length > 0) {
                const [x, y] = pixelStack.pop(); // Pop a pixel to fill
                const idx = (y * canvas.width + x) * 4; // Get the pixel index

                // Skip if the current pixel doesn't match the target color
                if (!colorsMatch(getPixelColor(pixels, x, y), targetColor)) continue;
                setPixelColor(pixels, idx, fillColor); // Set the pixel color to the fill color

                // Add neighboring pixels to the stack for filling
                if (x > 0) pixelStack.push([x - 1, y]);
                if (x < canvas.width - 1) pixelStack.push([x + 1, y]);
                if (y > 0) pixelStack.push([x, y - 1]);
                if (y < canvas.height - 1) pixelStack.push([x, y + 1]);
            }
            ctx.putImageData(imageData, 0, 0); // Apply the filled pixels back to the canvas
        }

        // Helper function to get the color of a pixel at (x, y)
        function getPixelColor(pixels, x, y) {
            const idx = (y * canvas.width + x) * 4; // Calculate the index of the pixel
            return [pixels[idx], pixels[idx + 1], pixels[idx + 2], pixels[idx + 3]]; // Return the RGBA values
        }

        // Helper function to set the color of a pixel
        function setPixelColor(pixels, idx, color) {
            pixels[idx] = color[0]; // Set the red value
            pixels[idx + 1] = color[1]; // Set the green value
            pixels[idx + 2] = color[2]; // Set the blue value
            pixels[idx + 3] = color[3]; // Set the alpha (opacity) value
        }

        // Helper function to check if two colors match (by comparing RGBA values)
        function colorsMatch(color1, color2) {
            return color1.every((v, i) => v === color2[i]); // Compare each color channel
        }

        // Helper function to convert a hex color code to RGB
        function hexToRgb(hex) {
            const bigint = parseInt(hex.slice(1), 16); // Convert hex string to a number
            return { r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255 }; // Extract RGB components
        }
    </script>
</body>
</html>
